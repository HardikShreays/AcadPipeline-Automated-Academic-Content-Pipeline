
================================================================================
Lecture Hash: 1
Total Chunks: 6
Processed At: Thu Jan 29 2026 10:58:51 GMT+0530 (India Standard Time)
Characters: 5748 | Words: 863 | Tokens: 1437
================================================================================

Starting with Newton written on the board. Let's take the ASCII values for each character, specifically the last digit of each ASCII code. For "Newton," this yields 897498. This represents the hash value for "Newton." When using Newton, the resulting hash is 897498.  

Hashing is one-way: you cannot reverse it to get the original input. Brute force could match inputs, but collisions are infrequent, making reversal impractical. We use salts instead of initial values to enhance security.  

Recalling last class: JWT tokens have three parts—header, payload, and signature. JWTs come in two types: JWE (encrypted) and JWS (signed). With JWE, you can decrypt the payload and header. With JWS, hashing creates the signature using the header, payload, and secret salt. Both header and payload are Base64-encoded, while the signature is the hash. By default, JWT uses signing (hashing), though encryption is possible.  

Today’s topic is refresh tokens. Consider Instagram’s requirement for persistent user sessions. Issuing a JWT with no expiry poses security risks. The correct approach uses OAuth tokens: an access token (JWT) with 24-hour expiry and a refresh token with 30-day expiry. Upon login, two tokens are generated. After 24 hours of inactivity, the access token expires.

I will check if the user exists and validate the password. Then I will generate two tokens: an access token valid for one minute and a refresh token valid for two minutes, both sent to the client.  

For fetching posts, the token should be in the Authorization header. If no token exists, return unauthorized. If token verification fails through synchronous JWT verification, return unauthorized.  

Testing the login API:  
- Server running on port 3000  
- Received tokens (access: 1 minute, refresh: 2 minutes validity)  

Testing protected post endpoint:  
1. Request without Authorization header: returns "Unauthorized"  
2. Request with expired token: returns "Unauthorized" due to JWT expiration  
3. Request with valid token (used immediately after login): successfully returns dummy post data  

Token management rules:  
- Refresh token should have longer expiry than access token (typically access: 24h, refresh: 30 days in production)  
- Auth flow: Verify token on protected routes. If verification fails (expired/invalid), return "Unauthorized".  

Error handling implemented through try-catch blocks during token verification. The post endpoint returns static dummy data when authentication succeeds.

The payload will match the encoded part, but the signature will not match. Only up to the expiration time will match. The signature does not match the header or payload. This token has expired. To demonstrate refresh tokens, we need another API endpoint: POST /refresh. This will take the refresh token from the header. If the refresh token doesn't exist, return unauthorized. If verified but not valid, return unauthorized. After verification, create new OAuth tokens and a new refresh token, then send them to the frontend.  

First, restart the server. The API requires authorization in the header with no request body. Start the authentication process. After login, the access token expires in one minute while the refresh token remains valid for two minutes. When the access token expires, sending a request returns unauthorized. However, using the valid refresh token generates a new access token valid for another minute. Using this new token grants access to posts again without relogging.  

After two minutes, the refresh token expires and returns unauthorized. After three minutes, nothing works. For permanent login, implement periodic refresh token usage. Typical services like Instagram have 60-day refresh token validity. Google's ecosystem maintains interconnected OAuth across services.  

For authorization middleware, add a role property to the token payload (e.g., 'student' vs 'admin'). The middleware checks the role in the token against required access levels. If the token claims 'student' role but the endpoint requires 'admin', return unauthorized. This is implemented through simple middleware validation.

When the role is admin, upon login, the payload includes roles. Posts can only be accessed by an admin. Middleware requires three parameters: request, token, and next. Here, the payload is extracted. If payload.role is not equal to admin, return a response. Otherwise, proceed to the next function. The middleware handles token authentication first, then user authorization for API access.  

Admin users have privileges to access these APIs. Server restart is required. Tokens are valid for 60 minutes. Testing with a student role results in unauthorized access to posts, as they lack authorization. This is handled in the middleware.  

The task involves building authentication and authorization middleware. Middleware accepts request, response, next. Use function binding to attach extra arguments. For example, binding creates a new function with preset arguments like 1, 2. When called, it executes with these arguments prepended. This principle applies to any function requiring argument binding.

You need to write a very generic middleware which can be used for authentication and authorization for any API with any level of access. OAuth provides authentication systems to third parties. Google built an authentication system and now provides it for others to use. If you log into LinkedIn via Google Sign-In, you're using Google's OAuth system for verification. Multiple OAuth providers exist like Google, Facebook, Apple - their structure is absolutely the same. Learning one provider's implementation allows you to work with others like LinkedIn.

I am ending the quiz. That's it for today. Thank you.



================================================================================
SUMMARY
================================================================================
Total Lectures: 1
Total Characters: 5748
Total Words: 863
Total Tokens (approx): 1437
================================================================================
