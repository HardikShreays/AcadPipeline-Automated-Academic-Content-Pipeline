
## Introduction


## 17


## Indexing & Query


## Optimisation


## By -


## C101: DBMS


## Quick Recap
So far we have learnt: ● Transaction ● ACID properties Dataset 1

## Data Retrieval in Large Databases
Imagine you want to find a piece of information from a large database. How would you retrieve? 2

## Data Retrieval in Large Databases
If the table was ordered alphabetically, searching for a name could happen a lot faster because we could skip looking for the data in certain rows. 4

## Efficient Data Retrieval
How can we order the table with respect to a column By using the for fast retrieval? concept of Indexing! 6

## Indexing
An index in SQL is similar to an index in a book. It helps the database find the exact rows that match your query quickly, without scanning the entire table. 7

## Use Case of Indexing


## Index Table
8

## Use Case of Indexing
Before creating an index Query:- EXPLAIN SELECT * FROM customers WHERE first_name=’priya’; Output:- id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered |Extra 1|SIMPLE|customers|NULL|ALL|NULL|NULL|NULL|NULL|7|14.29|Using where 9

## Use Case of Indexing
After creating an index Query:- CREATE INDEX a ON customers (first_name); Explain select * from customers where first_name="Priya"; Output:- id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra 1|SIMPLE|customers|NULL|ref|a|a|203|const|1|100.00|NULL 10

## Explain command
Explain select * from customers where first_name="Priya" What is Explain Keyword? 11

## Explain
The EXPLAIN keyword provides detailed information about how a query will be executed. It is used to obtain the following information about the query execution plan: id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows ● The ID of the query ● The type of your SELE...

## Internal Implementation
Indexing creates a separate How does data structure (typically a indexing works? B-Tree or B+ Tree) that the database uses to search for data more efficiently. 13

## Types of Indexing
How many types of indexing do we We have two types of have? indexing Clustered & Non-clustered. 21

## Clustered Index
A clustered index is a type of database index where the physical order of rows in a table matches the order of the indexed column. 22

## Clustered Index
Clustered index organizes the actual rows of data on disk based on a single column (like a genre label). It’s the physical arrangement of data, so only one clustered index is allowed per table. 23

## Clustered Index
-- Creating a clustered index in MySQL Each table can have only one clustered index, and by default, DB (MySQL’s default storage engine) creates a clustered index on the primary key. 24

## Clustered Index
But how do we check that index has been created on primary key? 25

## Clustered Index
By using INFORMATION_SCHEMA.STATISTICS table. is a INFORMATION_SCHEMA.STATISTICS system table that provides details about indexes on all tables in the database. It includes important metadata for each index, such as its name, type, associated columns, and how the index is organized. 26

## Clustered Index
Query:- SELECT INDEX_SCHEMA, INDEX_NAME, COLUMN_NAME, INDEX_TYPE, IS_VISIBLE FROM information_schema.statistics WHERE TABLE_NAME = 'customers'; Output:- INDEX_SCHEMA|INDEX_NAME|COLUMN_NAME|INDEX_TYPE|IS_VISIBLE test_db|PRIMARY|customer_id|BTREE|YES 27

## Multiple Indexing
What if we Need Multiple Indexes We can use on a Table? Non-clustered indexing. 28

## Non-Clustered Index
A non-clustered index creates a separate data structure (usually a B-Tree or B+ Tree) that references the actual data stored in the table. A table can have many non-clustered indexes, providing flexibility for multiple search patterns. 29

## Non-Clustered Index
A non-clustered index is separate from the data; it’s like a list that has pointers (addresses) to data rows. 30

## Creating Non Clustered Index
- - Syntax for creating a non-clustered index CREATE INDEX <index_name> ON <table_name> (column1, column2, ...); -- Creating a non-clustered index on first_name,state column CREATE INDEX cfs ON customers (first_name,state); 31

## Creating Non Clustered Index - - Checking the index columns
SELECT INDEX_SCHEMA, INDEX_NAME, COLUMN_NAME, INDEX_TYPE, IS_VISIBLE FROM information_schema.statistics WHERE TABLE_NAME = 'customers' ; OUTPUT: INDEX_SCHEMA INDEX_NAME COLUMN_NAME INDEX_TYPE IS_VISIBLE test_db cfs first_name BTREE YES test_db cfs state BTREE YES test_db PRIMARY customer_id BTREE YE...

## Dropping Non Clustered Index
--Syntax for dropping a non-clustered index DROP INDEX index_name ON table_name; Example: DROP INDEX cfs ON customers; 33

## Advantages of Indexing


## ● Improved Query Performance


## ● Efficient Data Access


## ● Optimized Data Sorting


## ● Consistent Data Performance


## ● Data Integrity
33

## Disadvantages of Indexing


## ● Increased Storage Space:


## ● Increased Maintenance Overhead:


## ● Slower Insert/Update Operations:


## ● Complexity in Choosing the Right Index
33

## Clustered vs Non-Clustered Index
Clustered Non-clustered Stores actual data rows in the index. Separate structure from the actual data rows. One per table because it changes the A table can have many non-clustered physical order of the data. indexes. Clustered indexes organize the actual data Non-clustered indexes provide flexible,...

## Why query Optimization?
● Enhance performance ● Reduce execution time ● Enhance the efficiency 3

## Best Practices #1
Suppose your task is to retrieve just the product name and category. Which query among the following two is optimized and why? SELECT * FROM products; SELECT product_name, category FROM products; 4

## Best Practices #1
SELECT * FROM products; → Retrieves all columns, leading to inefficiency with large tables (time/resources). SELECT product_name, category FROM products; → Optimized by selecting only needed columns, resulting in faster retrieval and reduced resource use. It’s better to select as few columns as poss...

## Best Practices #2
Suppose you want to check if any customer has placed an order in the last 30 days. What do you think is the optimal function to use, EXISTS or COUNT()? 6

## Best Practices #2
COUNT(): ● Counts all orders placed by each customer in the last 30 days. ● Can be slow with large datasets. EXISTS: ● Checks if a customer placed any orders in the last 30 days. ● It's faster because it stops once it finds one order. The best practice is to use EXISTS instead of COUNT() when you on...

## Best Practices #4
LIMIT is a trap: ● LIMIT speeds up performance, but doesn’t reduce costs. ● The row restriction of the LIMIT clause is applied after SQL databases scan the full range of data. 12

## Best Practices
Suppose you are at an e-commerce company and need to find products ordered by more than 100 customers. Which approach is more optimized: using IN or EXISTS? 13

## Best Practices
Query 1 SELECT product_id FROM products WHERE product_id IN ( SELECT product_id FROM orders GROUP BY product_id HAVING COUNT(DISTINCT customer_id) > 100 ); Query 2 SELECT product_id FROM products p WHERE EXISTS ( SELECT 1 FROM orders o WHERE o.product_id = p.product_id GROUP BY o.product_id HAVING C...

## Best Practices
IN Method: ● Builds a list of product_ids before filtering, using more memory. ● Less efficient on large datasets as it loads all matches before processing. EXISTS Method: ● Directly checks for matching rows without a list, saving memory. ● More efficient, especially on large datasets, as it stops a...

## Best Practices #3
To efficiently retrieve the row count in a MySQL database, which version of COUNT is best? SELECT COUNT(*) FROM table_name; SELECT COUNT(1) FROM table_name; SELECT COUNT(column_name) FROM table_name; SELECT COUNT(DISTINCT column_name) FROM table_name; 16

## Best Practices #
SELECT COUNT(*) FROM table_name; ● Counts all rows, including NULLs. ● Efficient and generally recommended for counting all rows in a table, as it’s handled at the database engine level without extra processing. SELECT COUNT(1) FROM table_name; ● Similar in function to COUNT(*). ● Replaces all query...

## Best Practices #
SELECT COUNT(column_name) FROM table_name; ● Counts only non-NULL values in the column. ● Useful when you need rows with data in a specific column. SELECT COUNT(DISTINCT column_name) FROM table_name; ● Counts unique, non-NULL values in the column. ● Ideal for distinct counts but may be slower on lar...

## Best Practices #
● Use COUNT(*) for counting all rows efficiently, including NULLs. ● Avoid COUNT(1) as it offers no performance advantage over COUNT(*). ● Use COUNT(column_name) when you need to count non-NULL entries in a specific column. ● Reserve COUNT(DISTINCT column_name) for counting unique values, keeping in...

## Best Practices #4
Which is more optimal: using just a SELECT clause or combining SELECT with a WHERE clause ? SELECT * FROM orders; SELECT order_id, customer_id FROM orders WHERE order_date >= '2024-01-01'; 22

## Best Practices #
Query 1: Retrieves all columns and rows, resulting in unnecessary data processing and higher memory usage. Query 2: ● Filters for relevant columns and rows, enhancing performance. ● Less data transferred, saving bandwidth and time. ● Faster query execution with less processed data. Filter and limit ...

## Best Practices #11
A retail chain operates multiple warehouses in various cities and needs to identify product quantities and types at each New York warehouse. Which is more optimized? –joins larger table to –joins smaller table to larger smaller table table SELECT w.warehouse_id, SELECT i.warehouse_id, w.location, i....

## Best Practices #11
Query 1 SELECT w.warehouse_id, w.location, i.product_id, i.quantity FROM warehouses AS w JOIN inventory AS i ON w.warehouse_id = i.warehouse_id WHERE w.city = 'New York'; ● Joins the warehouses table (larger) with the inventory table (smaller) , leading to potentially slower performance. ● Slower du...

## Best Practices #11
Improved Query: SELECT i.warehouse_id, i.product_id, i.quantity, w.location FROM inventory AS i JOIN warehouses AS w ON i.warehouse_id = w.warehouse_id WHERE w.city = 'New York'; ● Starting with the larger inventory table reduces rows earlier, optimizing performance. ● Faster due to early reduction ...

## Best Practices #12
A company wants to filter customer transactions by specific customer ID and transaction details. Does WHERE sequence matters? SELECT customer_id, transaction_date SELECT customer_id, transaction_date FROM transactions FROM transactions WHERE WHERE customer_name LIKE '%Smith%' customer_id = '12345678...

## Best Practices #12
Query 1 SELECT customer_id, transaction_date FROM transactions WHERE customer_name LIKE '%Smith%' AND transaction_type LIKE '%Online%' AND customer_id = '123456789'; Placing LIKE filters before customer_id may initially check more rows, slowing performance. 30

## Best Practices #12
Query 2: SELECT customer_id, transaction_date FROM transactions WHERE customer_id = '123456789' AND customer_name LIKE '%Smith%' AND transaction_type LIKE '%Online%'; Placing customer_id first reduces rows early, making execution faster 31

## Best Practices #12
Although MySQL's optimizer manages condition order, placing the most selective condition (e.g., customer_id) first can help with large datasets. 32

## Best Practices #13
Should We Push ORDER BY to the End of the Query? 33

## Best Practices #13
Query 1: WITH recent_sales AS ( SELECT * FROM sales WHERE sale_date BETWEEN '2023-01-01' AND '2023-01-31' ORDER BY transaction_id, sale_amount ), customer_details AS ( SELECT * FROM customers WHERE status = 'active' ORDER BY customer_id ) SELECT s.transaction_id, s.sale_amount, c.customer_name FROM ...

## Best Practices #13
Query 2: WITH recent_sales AS ( SELECT * FROM sales WHERE sale_date BETWEEN '2023-01-01' AND '2023-01-31' ), customer_details AS ( SELECT * FROM customers WHERE status = 'active' ) SELECT s.transaction_id, s.sale_amount, c.customer_name FROM recent_sales s JOIN customer_details c ON s.customer_id = ...

## Best Practices #13
Query 1: Slower due to sorting in CTEs before filtering and joining. Query 2: Faster as sorting happens only after filtering and joining. Sorting after filtering and joining is more efficient, with fewer rows to sort. 36

## Best Practices #
Should we avoid Subqueries? Query 2: Query 1: SELECT * SELECT e.* FROM employees FROM employees e WHERE department_id IN ( JOIN departments d ON SELECT id e.department_id = d.id FROM departments WHERE d.name = 'Sales'; WHERE name = 'Sales' ); 37

## Best Practices #
Query 1: SELECT * FROM employees WHERE department_id IN ( SELECT id FROM departments WHERE name = 'Sales' ); Slower due to the inner query execution. 38

## Best Practices #
Query 2: SELECT e.* FROM employees e JOIN departments d ON e.department_id = d.id WHERE d.name = 'Sales'; Faster, as the join avoids extra nesting. 39

## Best Practices #
● Use joins or temporary tables instead of subqueries. ● Joins often enhance performance by streamlining the query structure. 40

## Best Practices #
Should we prefer UNION ALL over UNION? 41

## Best Practices #
Query 1: SELECT name FROM employees WHERE status = 'active' UNION SELECT name FROM contractors WHERE status = 'active'; Slower because it sorts data to remove duplicates. 42

## Best Practices #
Query 2: SELECT name FROM employees WHERE status = 'active' UNION ALL SELECT name FROM contractors WHERE status = 'active'; Faster because it skips sorting to check for duplicates. 43

## Best Practices #15
● Use UNION ALL if duplicate removal isn’t needed. ● UNION ALL is faster as it skips sorting to eliminate duplicates. 44 ) Newton School of Technology 45

## Summary
● Select only needed columns to reduce data load. ● Efficient WHERE clause to filter data early. ● Limit rows with LIMIT for large datasets. ● Use UNION ALL Instead of UNION if duplicates aren’t needed. ● Use joins instead of subqueries when possible, and order joins from largest to smallest tables....

## Summary
So far we have learnt: ● Indexing ● Clustered Index ● Non Clustered Index ● Ways to Optimize queries 35 Questions Any 67

## Please fill the feedback form.


## Thanks


## for


## watching! 68
